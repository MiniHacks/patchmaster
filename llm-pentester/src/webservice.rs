use std::{
    collections::VecDeque,
    path::{Path, PathBuf}, time::Duration,
};

use anyhow::{bail, Context};
use axum::{body::StreamBody, response::{Response, Sse, sse::Event}, Form};
use futures::StreamExt;
use http::{StatusCode, Method};
use rand;
use serde::{Deserialize, Serialize};
use tempdir::TempDir;

use crate::llm::{self, ProblematicLine};

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct AuditRequest {
    repo_owner: String,
    repo_name: String,
}

pub async fn kick_off_pipeline(
    Form(req): Form<AuditRequest>,
) -> Result<
    StreamBody<impl futures::Stream<Item = Result<String, core::convert::Infallible>>>,
    StatusCode,
> {
    let (tx, rx) = tokio::sync::mpsc::unbounded_channel::<String>();

    println!("handling request...");
    tokio::spawn(async move {
        let tx_for_inner = tx.clone();
        let inner = async move {
            let tx = tx_for_inner;
            // Step 1: Clone the git repo into somewhere
            let github_url = format!("https://github.com/{}/{}.git", req.repo_owner, req.repo_name);
            let repo_dir = TempDir::new(&format!("llm_pentester_repo_{}", rand::random::<u16>()))
                .context("Failed to create temp dir")?;
            let _ = tx.send(format!("Cloning git repo (URL = {})...", github_url));

            tokio::time::sleep(Duration::from_secs(2)).await;
            let mut command = tokio::process::Command::new("git");
            command
                .arg("clone")
                .arg(github_url)
                .arg(repo_dir.path());

            let mut child = command.spawn().context("Failed to spawn Git process")?;
            let child_exit_code = child
                .wait()
                .await
                .context("Failed to wait for Git subprocess to complete")?;

            if !child_exit_code.success() {
                bail!("Git subprocess failed with exit code {:?}", child_exit_code)
            }

            // Step 2: Grep for all *.c files + read the contents
            let mut directories_to_read: VecDeque<PathBuf> =
                VecDeque::from_iter([repo_dir.path().to_owned()]);

            struct FileWithText {
                file_path: PathBuf,
                file_contents: String,
            }
            let mut list_of_c_files: Vec<FileWithText> = vec![];

            loop {
                // Get the next directory
                let Some(next_dir) = directories_to_read.pop_front() else { break; };
                let Ok(mut contents) = tokio::fs::read_dir(&next_dir).await else { 
                    let _ = tx.send(format!("Failed to read the files inside directory: {:?}", next_dir));
                    continue; 
                };

                // Loop through the entries
                'inner: loop {
                    match contents.next_entry().await {
                        Err(..) => {
                            let _ = tx
                                .send(format!("Failed to read a file from inside {:?}", next_dir));
                            continue 'inner;
                        }
                        Ok(Some(dir_entry)) => {
                            let path = dir_entry.path();
                            if dir_entry.metadata().await?.is_dir() {
                                directories_to_read.push_back(path);
                            } else if path.to_str().unwrap().ends_with(".c") {
                                let Ok(file_contents) = tokio::fs::read_to_string(&path).await else {
                                    let _ = tx.send(format!("Failed to read file contents from {:?}", path));
                                    continue 'inner;
                                };
                                list_of_c_files.push(FileWithText {
                                    file_path: dir_entry.path(),
                                    file_contents,
                                });
                            }
                        }
                        // No more to read
                        Ok(None) => {
                            break 'inner;
                        }
                    }
                }
            }


            let _ = tx.send(format!("Located {} C files, scanning them for vulnerabilities...", list_of_c_files.len()));
            
            for file in &list_of_c_files {
                let content = &file.file_contents;
                let content = html_escape::encode_text(content);
                let _ = tx.send(format!("<pre>{content}</pre>"));
            }
        /*
            // Step 3: Pass contents into the Auditor
            let mut all_problematic_lines = Vec::new();
            for file in &list_of_c_files {
                let results = ll    file.file_contents.as_str()).await;
                let _ = tx.send(format!("Scanned {:?}", file.file_path));
            
                for result in results {
                    all_problematic_lines.push((file.file_path.as_path(), result))
                }
            }

            // Step 4: Take results of Auditor and open github issues
            for (file_path, line) in all_problematic_lines {
                open_github_issue(&req.repo_owner, &req.repo_name, file_path, line).await.context("Failed to open github issue")?;
            }
*/
            Ok::<(), anyhow::Error>(())
        };

        let inner = inner.await;
        if let Err(e) = inner {
            let _ = tx.send(format!("Command completed with error:"));
            let _ = tx.send(format!("<pre>{:#?}</pre>", e));
        }
    });

    Ok(StreamBody::new(
        futures::stream::iter(["<ul>".to_owned()]).chain(
        tokio_stream::wrappers::UnboundedReceiverStream::new(rx)
            .map(|line| format!("<li> {line} </li>"))
            .chain(futures::stream::iter(["</ul>".to_owned()]))
        )
            .map(Ok),
    ))
}

async fn open_github_issue(repo_owner: &str, repo_name: &str, path: &Path, line: ProblematicLine) -> anyhow::Result<()> {
    #[derive(Debug, Clone, Serialize, Deserialize)]
    struct Issue {
        title: String,
        body: String
    }

    let resp = reqwest::Client::new().post(format!("https://api.github.com/repos/{repo_owner}/{repo_name}/issues"))
            .json(&Issue {
                title: "Issue with line".to_owned(),
                body: format!("
    There is an issue with the following line of code, located in file {path:?}:
    
    ```
    {}
    ```
    
    _Reason_: {}
                ", line.problematic_line, line.reason)
            })
            .header("User-Agent", "ritikmishra")
            .bearer_auth(std::env::var("HACKATHON_GITHUB_PAT").expect("get ritik to send you the github pat"))
            .send()
            .await?;

    Ok(())
}

// mod test {
//     use super::*;
//     #[tokio::test]
//     async fn test_open_an_issue() {
//         open_github_issue("x".as_ref(), ProblematicLine { problematic_line: "93 | banana".into(), reason: "owo!".into() }).await.unwrap();
//     }
// }