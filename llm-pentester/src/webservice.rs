use std::{
    collections::VecDeque,
    path::{Path, PathBuf}, time::Duration, process::Stdio,
};

use anyhow::{bail, Context};
use axum::{body::StreamBody, response::{Response, Sse, sse::Event}, Form};
use futures::StreamExt;
use http::{StatusCode, Method};
use rand;
use serde::{Deserialize, Serialize};
use tempdir::TempDir;
use tokio::io::AsyncReadExt;

use crate::llm::{self, ProblematicLine};

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct AuditRequest {
    repo_owner: String,
    repo_name: String,
}

pub async fn kick_off_pipeline(
    Form(req): Form<AuditRequest>,
) -> Result<
    StreamBody<impl futures::Stream<Item = Result<String, core::convert::Infallible>>>,
    StatusCode,
> {
    let (tx, rx) = tokio::sync::mpsc::unbounded_channel::<String>();

    println!("handling request...");
    tokio::spawn(async move {
        let tx_for_inner = tx.clone();
        let inner = async move {
            let tx = tx_for_inner;
            // Step 1: Clone the git repo into somewhere
            let github_url = format!("https://github.com/{}/{}.git", req.repo_owner, req.repo_name);
            let repo_dir = TempDir::new(&format!("llm_pentester_repo_{}", rand::random::<u16>()))
                .context("Failed to create temp dir")?;
            let _ = tx.send(format!(r#"Cloning git repo (URL = <a href="{github_url}">{github_url}</a>)..."#));

            let mut command = tokio::process::Command::new("git");
            command
                .arg("clone")
                .arg(github_url)
                .arg(repo_dir.path())
                .stdout(Stdio::piped());

            let mut child = command.spawn().context("Failed to spawn Git process")?;
            let child_exit_code = child
                .wait()
                .await
                .context("Failed to wait for Git subprocess to complete")?;

            if !child_exit_code.success() {
                bail!("Git subprocess failed with exit code {:?}", child_exit_code)
            }

            let git_hash = {
                let mut command = tokio::process::Command::new("git");

                command
                    .args(&["rev-parse", "HEAD"])
                    .current_dir(&repo_dir)
                    .stdout(Stdio::piped());

                let mut child = command.spawn().context("Failed to spawn Git process (for finding git hash)")?;
                let _exit_code = child.wait().await.context("Failed to wait for Git hash process to complete")?;

                let mut hash = String::new();
                child.stdout.unwrap().read_to_string(&mut hash).await;

                hash.trim().to_owned()
            };

            let _ = tx.send(format!("Git hash: <code>{}</code>", git_hash));

            // Step 2: Grep for all *.c files + read the contents
            let mut directories_to_read: VecDeque<PathBuf> =
                VecDeque::from_iter([repo_dir.path().to_owned()]);

            struct FileWithText {
                file_path: PathBuf,
                file_contents: String,
            }
            let mut list_of_c_files: Vec<FileWithText> = vec![];

            loop {
                // Get the next directory
                let Some(next_dir) = directories_to_read.pop_front() else { break; };
                let Ok(mut contents) = tokio::fs::read_dir(&next_dir).await else { 
                    let _ = tx.send(format!("Failed to read the files inside directory: {:?}", next_dir));
                    continue; 
                };

                // Loop through the entries
                'inner: loop {
                    match contents.next_entry().await {
                        Err(..) => {
                            let _ = tx
                                .send(format!("Failed to read a file from inside {:?}", next_dir));
                            continue 'inner;
                        }
                        Ok(Some(dir_entry)) => {
                            let path = dir_entry.path();
                            if dir_entry.metadata().await?.is_dir() {
                                directories_to_read.push_back(path);
                            } else if path.to_str().unwrap().ends_with(".c") {
                                let Ok(file_contents) = tokio::fs::read_to_string(&path).await else {
                                    let _ = tx.send(format!("Failed to read file contents from {:?}", path));
                                    continue 'inner;
                                };
                                list_of_c_files.push(FileWithText {
                                    file_path: dir_entry.path().strip_prefix(&repo_dir).expect("bro wtf this should totally work!").to_owned(),
                                    file_contents,
                                });
                            }
                        }
                        // No more to read
                        Ok(None) => {
                            break 'inner;
                        }
                    }
                }
            }


            let _ = tx.send(format!("Located {} C files, scanning them for vulnerabilities...", list_of_c_files.len()));
            
            // Step 3: Pass contents into the Auditor
            let mut child_task_handles = Vec::new();
            for file in &list_of_c_files {
                let _ = tx.send(format!("Starting to scan <code>{}</code>", file.file_path.to_string_lossy()));
                let results = llm::process_file_text(file.file_contents.as_str()).await?;
                let _ = tx.send(format!("Finished scanning <code>{}</code>, identified {} issues", file.file_path.to_string_lossy(), results.len()));
            

        
                // Step 4: Take results of Auditor and open github issues
                let repo_name = req.repo_name.clone();
                let repo_owner = req.repo_owner.clone();
                let da_hash = git_hash.clone();
                let file_path = file.file_path.clone();
                let tx = tx.clone();
                tokio::task_local! {}
                child_task_handles.push(tokio::spawn(async move {
                    for line in results {
                        let url = open_github_issue(&repo_owner, &repo_name, &da_hash, &file_path, line).await.context("Failed to open github issue")?;
                        let _ = tx.send(format!(r#"Opened issue: <a href="{url}">{url}</a>"#));
                    }

                    Ok::<(), anyhow::Error>(())
                }));
            }


            for child_task in child_task_handles {
                child_task.await??;
            }
            
            let _ = tx.send("All done!".to_owned());
            Ok::<(), anyhow::Error>(())
        };

        let inner = inner.await;
        if let Err(e) = inner {
            let _ = tx.send(format!("Command completed with error:"));
            let _ = tx.send(format!("<pre>{:#?}</pre>", e));
        }
    });

    Ok(StreamBody::new(
        futures::stream::iter(["<ul>".to_owned()]).chain(
        tokio_stream::wrappers::UnboundedReceiverStream::new(rx)
            .map(|line| format!("<li> {line} </li>"))
            .chain(futures::stream::iter(["</ul>".to_owned()]))
        )
            .map(Ok),
    ))
}

/// Open a GitHub issue on the given repo. Say that there's a problem on 
async fn open_github_issue(repo_owner: &str, repo_name: &str, commit_hash: &str, path: &Path, line: ProblematicLine) -> anyhow::Result<String> {
    #[derive(Debug, Clone, Serialize, Deserialize)]
    struct Issue {
        title: String,
        body: String
    }

    let path = path.to_string_lossy();

    let resp = reqwest::Client::new().post(format!("https://api.github.com/repos/{repo_owner}/{repo_name}/issues"))
            .json(&Issue {
                title: format!("Potential security issue in `{path}`"),
                body: format!("There is an issue with the following line of code, located in file `{path}`:

https://github.com/{repo_owner}/{repo_name}/blob/{commit_hash}/{path}#L{start_line}-L{end_line}):

_Reason_: {reason}", reason=line.reason, start_line=line.start_range, end_line=line.end_range)
            })
            .header("User-Agent", "ritikmishra")
            .bearer_auth(std::env::var("HACKATHON_GITHUB_PAT").expect("get ritik to send you the github pat"))
            .send()
            .await?;

    #[derive(Clone, Debug, Serialize, Deserialize)]
    struct Response  {
        html_url: String
    }

    let Response { html_url } = resp.json::<Response>().await.context("The response is supposed to have a `url` field!")?;

    Ok(html_url)
}
