use anyhow::Context;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ProblematicLine {
    pub start_range: usize,
    pub end_range: usize,
    pub problematic_line: String,
    pub reason: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct RequestBodyOuter {
    input: RequestBodyInner,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct RequestBodyInner {
    input: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ResponseBody {
    output: String
}

pub async fn process_file_text(text: &str) -> anyhow::Result<Vec<ProblematicLine>> {
    let request = reqwest::Client::new()
        .post(std::env::var("HACKATHON_SPELLBOOK_URL").expect("grab the URL from spellbook"))
        .header("Authorization", std::env::var("HACKATHON_SPELLBOOK_AUTH").expect("grab the auth from spellbook"))
        .json(&RequestBodyOuter {
            input: RequestBodyInner {
                input: text.to_owned(),
            },
        })
        .send()
        .await
        .context("Failed to query spellbook")?;

    let text = request
        .json::<ResponseBody>()
        .await
        .context("Spellbook did not give us a happy response")?
        .output;

    let results = identify_problems_from_annotated_code(text);

    Ok(results)
}

fn identify_problems_from_annotated_code(text: String) -> Vec<ProblematicLine> {
    let lines = text.lines().collect::<Vec<_>>();
    let mut results = vec![];
    for (i, line) in lines.iter().enumerate() {
        let line_split_reason = line.split("// SECAI: ").collect::<Vec<_>>();
        if line_split_reason.len() == 2 {
            let reason = line_split_reason[1].to_owned();
            let pre_context = ((i as i32 - 2).max(0_i32)) as usize;
            let post_context = (i + 3).min(lines.len());

            // NOTE: We add 1 to `idx` (and `i` later) because line numbers start from 1, but `enumerate` starts from 0
            let lines_for_context =
                Iterator::zip(pre_context..post_context, &lines[pre_context..post_context])
                    .map(|(idx, line)| {
                        let idx = idx + 1;
                        let line = line.split("// SECAI: ").nth(0).unwrap();
                        format!("{idx:>5} | {line}\n")
                    })
                    .fold(String::new(), |mut acc, el| {
                        acc.push_str(&el);
                        acc
                    });

            results.push(ProblematicLine {
                start_range: pre_context + 1,
                end_range: post_context,
                problematic_line: lines_for_context,
                reason,
            });
        }
    }
    results
}

mod test {
    use super::identify_problems_from_annotated_code;

    #[test]
    fn test_annotations() {
        let str = r###"#include <stdio.h>
#include <stdlib.h>

/* Like strcpy(), but with return-address checking */
void my_strcpy(char *dest, char *src) {
    void *orig_ret = __builtin_return_address(0);

    char *p = src;
    char *q = dest;
    while (*p) {
	*q++ = *p++; // SECAI: This line can lead to a buffer overflow if the source string is longer than the destination buffer.
    }
    *q = 0;

    void *new_ret = __builtin_return_address(0);
    if (new_ret != orig_ret) {
	fprintf(stderr, "strcpy return address corrupted to %p\n", new_ret);
	exit(42);
    }
}

void func(char *attacker_controlled) {
    void *orig_ret = __builtin_return_address(0);
    char buffer[50];

    my_strcpy(&buffer[0], attacker_controlled); // SECAI: This line can lead to a buffer overflow if the attacker_controlled string is longer than 50 characters.

    void *new_ret = __builtin_return_address(0);
    if (new_ret != orig_ret) {
	fprintf(stderr, "func return address corrupted to %p\n", new_ret);
	exit(42);
    }
}

int main(int argc, char **argv) {
    if (argc == 2) {
	func(argv[1]); // SECAI: This line can lead to a buffer overflow if the command line argument is longer than 50 characters.
    } else {
	func("short");
    }
    return 0;
}"###.to_owned();
        assert_eq!(3, identify_problems_from_annotated_code(str).len())
    }
}
